const { Pool } = require('pg');
const isProduction = process.env.NODE_ENV === 'production' || process.env.PORT;
const config = require(isProduction ? './config.production' : './config');

async function removePseudoDuplicates() {
    const pool = new Pool(config.dbConfig);
    const client = await pool.connect();

    try {
        console.log('üóëÔ∏è –ù–∞—á–∏–Ω–∞–µ–º —É–¥–∞–ª–µ–Ω–∏–µ –∏—Å—Ç–∏–Ω–Ω—ã—Ö –ø—Å–µ–≤–¥–æ-–¥—É–±–ª–∏–∫–∞—Ç–æ–≤ (–æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –æ–ø–∏—Å–∞–Ω–∏—è)...\n');

        // –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ —Å –ø—Å–µ–≤–¥–æ-–¥—É–±–ª–∏–∫–∞—Ç–∞–º–∏
        const pseudoDuplicateCategories = [
            'coin',      // –ú–æ–Ω–µ—Ç—ã
            'other',     // –ü—Ä–æ—á–µ–µ
            'banknote'   // –ë–∞–Ω–∫–Ω–æ—Ç—ã
        ];

        let totalRemoved = 0;

        for (const category of pseudoDuplicateCategories) {
            console.log(`üè∑Ô∏è –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é: ${category}`);
            
            // –ù–∞—Ö–æ–¥–∏–º –¥—É–±–ª–∏–∫–∞—Ç—ã –¥–ª—è —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (–æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –æ–ø–∏—Å–∞–Ω–∏—è)
            const duplicateQuery = `
                SELECT 
                    original_description,
                    COUNT(*) as count,
                    STRING_AGG(id::text, ', ' ORDER BY id) as ids,
                    MIN(id) as keep_id
                FROM coin_catalog 
                WHERE category = $1
                GROUP BY original_description
                HAVING COUNT(*) > 1
                ORDER BY count DESC
            `;

            const duplicateResult = await client.query(duplicateQuery, [category]);
            
            if (duplicateResult.rows.length === 0) {
                console.log('   ‚úÖ –î—É–±–ª–∏–∫–∞—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
                continue;
            }

            console.log(`   üîç –ù–∞–π–¥–µ–Ω–æ ${duplicateResult.rows.length} –≥—Ä—É–ø–ø –¥—É–±–ª–∏–∫–∞—Ç–æ–≤`);

            let categoryRemoved = 0;
            let processedGroups = 0;

            for (const group of duplicateResult.rows) {
                const count = parseInt(group.count);
                const toRemove = count - 1; // –û—Å—Ç–∞–≤–ª—è–µ–º –æ–¥–Ω—É –∑–∞–ø–∏—Å—å
                const idsToRemove = group.ids.split(', ').slice(1); // –£–¥–∞–ª—è–µ–º –≤—Å–µ –∫—Ä–æ–º–µ –ø–µ—Ä–≤–æ–π

                if (idsToRemove.length > 0) {
                    // –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
                    const deleteQuery = `
                        DELETE FROM coin_catalog 
                        WHERE id = ANY($1::int[])
                    `;
                    
                    await client.query(deleteQuery, [idsToRemove]);
                    categoryRemoved += toRemove;
                }

                processedGroups++;
                
                if (processedGroups % 100 === 0) {
                    console.log(`     üìà –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –≥—Ä—É–ø–ø: ${processedGroups}/${duplicateResult.rows.length}`);
                }
            }

            console.log(`   ‚úÖ –£–¥–∞–ª–µ–Ω–æ ${categoryRemoved} –∑–∞–ø–∏—Å–µ–π –∏–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ${category}`);
            totalRemoved += categoryRemoved;
        }

        console.log(`\nüéâ –£–¥–∞–ª–µ–Ω–∏–µ –∏—Å—Ç–∏–Ω–Ω—ã—Ö –ø—Å–µ–≤–¥–æ-–¥—É–±–ª–∏–∫–∞—Ç–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!`);
        console.log(`üìä –í—Å–µ–≥–æ —É–¥–∞–ª–µ–Ω–æ –∑–∞–ø–∏—Å–µ–π: ${totalRemoved}`);

        // –ü—Ä–æ–≤–µ—Ä–∏–º –∏—Ç–æ–≥–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        console.log(`\nüìà –ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º:`);
        const statsQuery = `
            SELECT 
                category,
                COUNT(*) as count
            FROM coin_catalog 
            GROUP BY category
            ORDER BY count DESC
        `;
        
        const statsResult = await client.query(statsQuery);
        statsResult.rows.forEach(row => {
            console.log(`   ${row.category}: ${row.count} –∑–∞–ø–∏—Å–µ–π`);
        });

        const totalRemaining = statsResult.rows.reduce((sum, row) => sum + parseInt(row.count), 0);
        console.log(`\nüìä –í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π –≤ –∫–∞—Ç–∞–ª–æ–≥–µ: ${totalRemaining}`);

        // –ü—Ä–æ–≤–µ—Ä–∏–º, —Å–∫–æ–ª—å–∫–æ –æ—Å—Ç–∞–ª–æ—Å—å –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
        console.log(`\nüîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –¥—É–±–ª–∏–∫–∞—Ç–æ–≤:`);
        const remainingDuplicatesQuery = `
            SELECT 
                category,
                COUNT(*) as duplicate_groups,
                SUM(count - 1) as records_to_remove
            FROM (
                SELECT 
                    category,
                    original_description,
                    COUNT(*) as count
                FROM coin_catalog 
                GROUP BY category, original_description
                HAVING COUNT(*) > 1
            ) as duplicates
            GROUP BY category
            ORDER BY records_to_remove DESC
        `;
        
        const remainingDuplicatesResult = await client.query(remainingDuplicatesQuery);
        if (remainingDuplicatesResult.rows.length > 0) {
            console.log('   –û—Å—Ç–∞–≤—à–∏–µ—Å—è –¥—É–±–ª–∏–∫–∞—Ç—ã:');
            remainingDuplicatesResult.rows.forEach(row => {
                console.log(`   ${row.category}: ${row.duplicate_groups} –≥—Ä—É–ø–ø, ${row.records_to_remove} –∑–∞–ø–∏—Å–µ–π –∫ —É–¥–∞–ª–µ–Ω–∏—é`);
            });
        } else {
            console.log('   ‚úÖ –î—É–±–ª–∏–∫–∞—Ç–æ–≤ –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å!');
        }

    } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø—Å–µ–≤–¥–æ-–¥—É–±–ª–∏–∫–∞—Ç–æ–≤:', error);
    } finally {
        client.release();
        await pool.end();
    }
}

removePseudoDuplicates();
